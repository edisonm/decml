/* BC_LINE_LENGTH=0 bc -l lanczos.bc */

scale = 100

define pi() {
  auto p
  p = 4*a(1)
  return p
}

define pow(x, y) {
  /* real power: x^y = exp(y*ln(x)) */
  return e(y * l(x))
}

define sqrt2pi() {
  return sqrt(2*pi())
}

define b(g, z) {
  auto t
  t = z + g + .5
  return sqrt2pi() * pow(t, z + .5) / e(t)
}

define lb(g, z) {
  auto t
  t = z + g + .5
  return (l(2*pi())/2) + (z + .5)*l(t) - t
}

define fact(n) {
  auto i, f
  f = 1
  for (i = 2; i <= n; i++) f *= i
  return f
}

/* a(z) = p0 + p1/(z+1) + p2/(z+2) + ... */
define lanczos_a(p[], n, z) {
  auto s, j
  s = p[0]
  for (j = 1; j < n; j++) {
    s += p[j] / (z + j)
  }
  return s
}

/* absolute value */
define abs(x) {
  if (x < 0) return -x
  return x
}

/*
  Solve for coefficients p[0..n-1] using square system k=0..n-1:

    p0 + p1/(k+1) + p2/(k+2) + ... + p(n-1)/(k+n-1) = fact(k)/b(g,k)

  Uses gaussian elimination with partial pivoting.
  Matrices are stored as 1D vectors:
    a[row*n + col]
*/
define lanczos_coeffs(g, n, &p[]) {
  auto a[], rhs[], i, j, k, pivot, tmp, m, idx1, idx2

  /* build system */
  for (k = 0; k < n; k++) {
    rhs[k] = fact(k) / b(g, k)
    for (j = 0; j < n; j++) {
      if (j == 0) {
        a[k*n + j] = 1
      } else {
        a[k*n + j] = 1 / (k + j)
      }
    }
  }

  /* forward elimination */
  for (i = 0; i < n; i++) {

    /* choose pivot row */
    pivot = i
    for (k = i + 1; k < n; k++) {
      if (abs(a[k*n + i]) > abs(a[pivot*n + i])) pivot = k
    }

    /* swap rows i and pivot */
    if (pivot != i) {
      for (j = i; j < n; j++) {
        idx1 = i*n + j
        idx2 = pivot*n + j
        tmp = a[idx1]
        a[idx1] = a[idx2]
        a[idx2] = tmp
      }
      tmp = rhs[i]; rhs[i] = rhs[pivot]; rhs[pivot] = tmp
    }

    /* eliminate below */
    for (k = i + 1; k < n; k++) {
      m = a[k*n + i] / a[i*n + i]
      for (j = i; j < n; j++) {
        a[k*n + j] -= m * a[i*n + j]
      }
      rhs[k] -= m * rhs[i]
    }
  }

  /* back substitution */
  for (i = n - 1; i >= 0; i--) {
    tmp = rhs[i]
    for (j = i + 1; j < n; j++) {
      tmp -= a[i*n + j] * p[j]
    }
    p[i] = tmp / a[i*n + i]
  }

  return 0
}

/*
  True Gamma(z) using your Prolog structure but correcting the +1 bias:
    Prolog gamma(G,N,Z) computes approx Gamma(Z+1)
  So here:
    gamma(z) = b(g, z-1) * a(z-1)
*/
define gamma_lanczos(g, n, z, p[]) {
  auto zm1
  zm1 = z - 1
  return b(g, zm1) * lanczos_a(p[], n, zm1)
}

/* True log-gamma */
define lgamma_lanczos(g, n, z, p[]) {
  auto zm1
  zm1 = z - 1
  return lb(g, zm1) + l(lanczos_a(p[], n, zm1))
}

define print_coeffs(n, p[]) {
  auto i
  for (i = 0; i < n; i++) {
    print p[i], "\n"
  }
  return 0
}

/* floor(x): largest integer <= x */
define floor(x) {
  auto i, ps

  /* truncate toward 0 */
  ps = scale
  scale = 0
  i = x / 1
  scale = ps

  /* if x is negative and not already integer, subtract 1 */
  if (x < 0 && x != i) {
    i = i - 1
  }

  return i
}

/* ceil(x): smallest integer >= x */
define ceil(x) {
  auto i, ps

  /* truncate toward 0 */
  ps = scale
  scale = 0
  i = x / 1
  scale = ps

  /* if x is positive and not already integer, add 1 */
  if (x > 0 && x != i) {
    i = i + 1
  }

  return i
}

/* round(x): nearest integer, ties (fraction 0.5) away from 0 */
define round(x) {
  auto i, f, r, ps

  /* truncate toward 0 */
  ps = scale
  scale = 0
  i = x / 1
  scale = ps

  /* fractional part magnitude */
  if (x >= 0) {
    f = x - i
  } else {
    f = i - x
  }

  if (f < 0.5) {
    r = i
  } else {
    if (x >= 0) {
      r = i + 1
    } else {
      r = i - 1
    }
  }

  return r
}

/* example: compute coefficients and test gamma */
define demo() {
  auto g, n, p[], z
  g = 7
  n = 9
  lanczos_coeffs(g, n, p[])
  print_coeffs(n, p[])

  z = 5
  print "gamma(", z, ") ~ ", gamma_lanczos(g, n, z, p[]), "\n"
  print "lgamma(", z, ") ~ ", lgamma_lanczos(g, n, z, p[]), "\n"
  return 0
}

define print_dec128_list(n, x[]) {
  auto i
  for (i = 0; i < n; i++) {
    ret=print_dec128(x[i], 0)
  }
  return 0
}

define dump_lanczos_dec128_coef(g, n) {
  auto p[]
  print "const int LANCZOS_dec128_N = ", n, ";\n"
  print "const intern_dec128_t lanczos_dec128_g = {0, ", g, ", 0, DEC_NORMAL};\n\n"
  print "const intern_dec128_t lanczos_dec128_coef[] = {\n"
  r=lanczos_coeffs(g,n,p[])
  r=print_dec128_list(n,p[])
  print "};\n"
}

p264m1 = 2^64-1

define print_dec64(a, exp) {
  auto x, y, s, k
  if (a < 0) {
    s = 1
    y = -a
  } else {
    s = 0
    y = a
  }
  if (y == 0) {
    k = 0
    x = 0
  } else {
    x = floor(l(y)/l(10)-19)
    y = y/10^x
    if (y > p264m1) {
      x = x+1
      y /= 10
    }
    k=round(y)
  }
  print "        {", s, ", ", k, "ULL, ", x+exp, ", DEC_NORMAL}, /*", k, "e", x+exp, "*/\n"
}

define print_dec64_list(n, x[]) {
  auto i
  for (i = 0; i < n; i++) {
    ret=print_dec64(x[i], 0)
  }
  return 0
}

define dump_lanczos_dec64_coef(g, n) {
  auto p[]
  print "const int LANCZOS_dec64_N = ", n, ";\n"
  print "const intern_dec64_t lanczos_dec64_g = {0, ", g, ", 0, DEC_NORMAL};\n\n"
  print "const intern_dec64_t lanczos_dec64_coef[] = {\n"
  r=lanczos_coeffs(g,n,p[])
  r=print_dec64_list(n,p[])
  print "};\n"

}

define dump_pow10m1_dec64_table(n) {
  auto x, i, y
  for (x = 1; x <= n; x++) {
    print "    {\n"
    for (i = 1; i <= 9; i++) {
      scale=20+x
      y = 10^x*(e(i*l(10)/10^x)-1)
      scale=20
      y = y/1
      r=print_dec64(y, -x)
    }
    print "    },\n"
  }
}

p2128m1 = 2^128-1

define print_dec128(a, exp) {
  auto x, y, s, k, k1, k2
  if (a < 0) {
    s = 1
    y = -a
  } else {
    s = 0
    y = a
  }
  if (y == 0) {
    k = 0
    x = 0
  } else {
    x = floor(l(y)/l(10)-38)
    y = y/10^x
    if (y > p2128m1) {
      x = x+1
      y /= 10
    }
    k=round(y)
  }
  k1 = floor(k/2^64)
  k2 = k - k1*2^64
  print "        {", s, ", ((__uint128_t)", k1, "ULL<<64)+ ", k2, "ULL, "
  print x+exp, ", DEC_NORMAL}, /*", k, "e", x+exp, " */\n"
}

define dump_pow10m1_dec128_table(n) {
  auto x, i, y
  for (x = 1; x <= n; x++) {
    print "    {\n"
    for (i = 1; i <= 9; i++) {
      scale=50+x
      y = 10^x*(e(i*l(10)/10^x)-1)
      scale=50
      y = y/1
      r=print_dec128(y, -x)
    }
    print "    },\n"
  }
}
