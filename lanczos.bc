/* BC_LINE_LENGTH=0 bc -l lanczos.bc */

scale = 100

define pi() {
  auto p
  p = 4*a(1)
  return p
}

define pow(x, y) {
  /* real power: x^y = exp(y*ln(x)) */
  return e(y * l(x))
}

define sqrt2pi() {
  return sqrt(2*pi())
}

define b(g, z) {
  auto t
  t = z + g + .5
  return sqrt2pi() * pow(t, z + .5) / e(t)
}

define lb(g, z) {
  auto t
  t = z + g + .5
  return (l(2*pi())/2) + (z + .5)*l(t) - t
}

define fact(n) {
  auto i, f
  f = 1
  for (i = 2; i <= n; i++) f *= i
  return f
}

/* a(z) = p0 + p1/(z+1) + p2/(z+2) + ... */
define lanczos_a(p[], n, z) {
  auto s, j
  s = p[0]
  for (j = 1; j < n; j++) {
    s += p[j] / (z + j)
  }
  return s
}

/* absolute value */
define abs(x) {
  if (x < 0) return -x
  return x
}

/*
  Solve for coefficients p[0..n-1] using square system k=0..n-1:

    p0 + p1/(k+1) + p2/(k+2) + ... + p(n-1)/(k+n-1) = fact(k)/b(g,k)

  Uses gaussian elimination with partial pivoting.
  Matrices are stored as 1D vectors:
    a[row*n + col]
*/
define lanczos_coeffs(g, n, &p[]) {
  auto a[], rhs[], i, j, k, pivot, tmp, m, idx1, idx2

  /* build system */
  for (k = 0; k < n; k++) {
    rhs[k] = fact(k) / b(g, k)
    for (j = 0; j < n; j++) {
      if (j == 0) {
        a[k*n + j] = 1
      } else {
        a[k*n + j] = 1 / (k + j)
      }
    }
  }

  /* forward elimination */
  for (i = 0; i < n; i++) {

    /* choose pivot row */
    pivot = i
    for (k = i + 1; k < n; k++) {
      if (abs(a[k*n + i]) > abs(a[pivot*n + i])) pivot = k
    }

    /* swap rows i and pivot */
    if (pivot != i) {
      for (j = i; j < n; j++) {
        idx1 = i*n + j
        idx2 = pivot*n + j
        tmp = a[idx1]
        a[idx1] = a[idx2]
        a[idx2] = tmp
      }
      tmp = rhs[i]; rhs[i] = rhs[pivot]; rhs[pivot] = tmp
    }

    /* eliminate below */
    for (k = i + 1; k < n; k++) {
      m = a[k*n + i] / a[i*n + i]
      for (j = i; j < n; j++) {
        a[k*n + j] -= m * a[i*n + j]
      }
      rhs[k] -= m * rhs[i]
    }
  }

  /* back substitution */
  for (i = n - 1; i >= 0; i--) {
    tmp = rhs[i]
    for (j = i + 1; j < n; j++) {
      tmp -= a[i*n + j] * p[j]
    }
    p[i] = tmp / a[i*n + i]
  }

  return 0
}

/*
  True Gamma(z) using your Prolog structure but correcting the +1 bias:
    Prolog gamma(G,N,Z) computes approx Gamma(Z+1)
  So here:
    gamma(z) = b(g, z-1) * a(z-1)
*/
define gamma_lanczos(g, n, z, p[]) {
  auto zm1
  zm1 = z - 1
  return b(g, zm1) * lanczos_a(p[], n, zm1)
}

/* True log-gamma */
define lgamma_lanczos(g, n, z, p[]) {
  auto zm1
  zm1 = z - 1
  return lb(g, zm1) + l(lanczos_a(p[], n, zm1))
}

define print_coeffs(n, p[]) {
  auto i
  for (i = 0; i < n; i++) {
    print p[i], "\n"
  }
  return 0
}

/* floor(x): largest integer <= x */
define floor(x) {
  auto i, ps

  /* truncate toward 0 */
  ps = scale
  scale = 0
  i = x / 1
  scale = ps

  /* if x is negative and not already integer, subtract 1 */
  if (x < 0 && x != i) {
    i = i - 1
  }

  return i
}

/* ceil(x): smallest integer >= x */
define ceil(x) {
  auto i, ps

  /* truncate toward 0 */
  ps = scale
  scale = 0
  i = x / 1
  scale = ps

  /* if x is positive and not already integer, add 1 */
  if (x > 0 && x != i) {
    i = i + 1
  }

  return i
}

/* round(x): nearest integer, ties (fraction 0.5) away from 0 */
define round(x) {
  auto i, f, r, ps

  /* truncate toward 0 */
  ps = scale
  scale = 0
  i = x / 1
  scale = ps

  /* fractional part magnitude */
  if (x >= 0) {
    f = x - i
  } else {
    f = i - x
  }

  if (f < 0.5) {
    r = i
  } else {
    if (x >= 0) {
      r = i + 1
    } else {
      r = i - 1
    }
  }

  return r
}

define float128(x, &sign[], &exp[], &coef[]) {
  if(x < 0) {
    sign[0] = 1
    y = -x
  } else {
    y = x
    sign[0] = 0
  }
  int128max = 2^128-1
  exp[0] = ceil((l(y)-l(int128max))/l(10))
  coef[0] = round(y/pow(10, exp[0]))
}

define max(x, y) {
  if (x>y) {
    return x
  } else {
    return y
  }
}

define coef128to64(y, &c[], &e[]) {
  int64max = 2^64-1
  e[0] = 10^ceil((l(y)-l(int64max))/l(10))
  c[0] = floor(y/e[0])
  r  = y - c[0] * e[0]
  e[1] = 10^max(0,ceil((l(r)-l(int64max))/l(10)))
  c[1] = floor(r/e[1])
  c[2] = r - c[1] * e[1]
}

define print_dec128(x) {
  auto sign[], exp[], coef[], c[], e[]
  ret = float128(x, sign[], exp[], coef[])
  ret = coef128to64(coef[0], c[], e[])
  ps = scale
  scale = 0
  print "    {", sign[0], ","
  if (c[0] < 10000000000000000000) {
    print " "
  }
  if (e[0] < 2^64) {
    print " (__uint128_t)", c[0], "ULL * ", e[0], "ULL"
    if (c[1] != 0) {
      print " + ", c[1], "ULL"
    }
    print ", ", exp[0], ", DEC_NORMAL},\n"
  } else if (e[1] == 10) {
    e01 = e[0] / e[1]
    if (c[2] == 0) {
      exp2 = exp[0] + 1
      print " (__uint128_t)", c[0], "ULL * ", e01, "ULL"
      if (c[1] != 0) {
        print " + ", c[1], "ULL"
      }
      print ", ", exp2, ", DEC_NORMAL},\n"
    } else {
      print "((__uint128_t)", c[0], "ULL * ", e01, "ULL"
      if (c[1] != 0) {
        print " + ", c[1], "ULL"
      }
      print ")*", e[1], "+", c[2], ", ", exp[0], ", DEC_NORMAL},\n"
    }
  } else {
    e01 = e[0] / 10
    if (c[1] % 10 == 0) {
      c10 = c[1] / 10
      exp2 = exp[0] + 1
      print " (__uint128_t)", c[0], "ULL * ", e01, "ULL + ", c10, "ULL, ", exp2, ", DEC_NORMAL},\n"
    } else {
      if (c[1] == 0) {
        print "((__uint128_t)", c[0], "ULL * ", e01, "ULL)*10, ", exp[0], ", DEC_NORMAL},\n"
      } else {
        print "((__uint128_t)", c[0], "ULL * ", e01, "ULL)*10 + ", c[1], "ULL, ", exp[0], ", DEC_NORMAL},\n"
      }
    }
  }
  scale = ps
}

/* example: compute coefficients and test gamma */
define demo() {
  auto g, n, p[], z
  g = 7
  n = 9
  lanczos_coeffs(g, n, p[])
  print_coeffs(n, p[])

  z = 5
  print "gamma(", z, ") ~ ", gamma_lanczos(g, n, z, p[]), "\n"
  print "lgamma(", z, ") ~ ", lgamma_lanczos(g, n, z, p[]), "\n"
  return 0
}

define print_dec128_list(n, x[]) {
  auto i
  for (i = 0; i < n; i++) {
    ret=print_dec128(x[i])
  }
  return 0
}

define dump_lanczos_dec128_coef(g, n) {
  auto p[]
  print "const int LANCZOS_dec128_N = ", n, ";\n"
  print "const intern_dec128_t lanczos_dec128_g = {0, ", g, ", 0, DEC_NORMAL};\n\n"
  print "const intern_dec128_t lanczos_dec128_coef[] = {\n"
  r=lanczos_coeffs(g,n,p[])
  r=print_dec128_list(n,p[])
  print "};\n"

}

c64_1 = (2^64-1)/10^18
c64_2 = (2^64-1)/10^19

p264m1 = 2^64-1

define print_dec64(y) {
  if (y < 0) {
    s = 1
    y = -y
  } else {
    s = 0
  }
  if (y == 0) {
    k = 0
    x = 0
  } else {
    pscale=scale
    x = l(y)/l(10)-19
    scale=0
    x /= 1
    scale=pscale
    y = y/10^x
    if (y > p264m1) {
      x++
      y /= 10
    }
    scale=0
    k=(y+0.5)/1
    scale=pscale
  }
  print "        {", s, ", ", k, "ULL, ", x, ", DEC_NORMAL},\n"
}

define print_dec64_list(n, x[]) {
  auto i
  for (i = 0; i < n; i++) {
    ret=print_dec64(x[i])
  }
  return 0
}

define dump_lanczos_dec64_coef(g, n) {
  auto p[]
  print "const int LANCZOS_dec64_N = ", n, ";\n"
  print "const intern_dec64_t lanczos_dec64_g = {0, ", g, ", 0, DEC_NORMAL};\n\n"
  print "const intern_dec64_t lanczos_dec64_coef[] = {\n"
  r=lanczos_coeffs(g,n,p[])
  r=print_dec64_list(n,p[])
  print "};\n"

}

define print_dec64_2(s, x, y) {
  if (y > c64_1) {
    exp = 16
  } else if (y > c64_2) {
    exp = 17
  } else
    exp = 18
  z = 10^exp*y
  scale=0
  k=(z+0.5)/1
  print "        {", s, ", ", k, "ULL, ", x-exp, ", DEC_NORMAL},\n"
}

define dump_pow10m1_dec64_table(n) {
  auto x, i, y
  for (x = 1; x <= n; x++) {
    print "    {\n"
    for (i = 1; i <= 9; i++) {
      scale=30+x
      y = 10^x*(e(i*l(10)/10^x)-1)
      r=print_dec64_2(0, -x, y)
    }
    print "    },\n"
  }
}

c128_1 = (2^128-1)/10^37
c128_2 = (2^128-1)/10^38

define print_dec128_2(s, x, y) {
  if (y > c128_1) {
    exp = 36
  } else if (y > c128_2) {
    exp = 37
  } else
    exp = 38
  z = 10^exp*y
  scale=0
  obase=16
  print "        {", s, ", "
  k=(z+0.5)/1
  print "((__uint128_t)0x", k/2^64, "ULL<<64)+ ", "0x", k%2^64, "ULL, "
  obase=10
  print x-exp
  print ", DEC_NORMAL},\n"
}

define dump_pow10m1_dec128_table(n) {
  auto x, i, y
  for (x = 1; x <= n; x++) {
    print "    {\n"
    for (i = 1; i <= 9; i++) {
      scale=50+x
      y = 10^x*(e(i*l(10)/10^x)-1)
      r=print_dec128_2(0, -x, y)
    }
    print "    },\n"
  }
}
